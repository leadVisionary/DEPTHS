/* Generated by Together */

package depths.pedagogicalModule;
import depths.pedagogicalModule.studentAssessment.*;
import depths.pedagogicalModule.instructionalPlanner.DiscoursePlanner;
import depths.coordinator.PedagogicalModuleFacade;
import java.util.*;
import depths.pedagogicalModule.studentAssessment.charts.ConceptHitChart;
public class Course {



  private DiscoursePlanner dPlanner;
  private int userId;
  private double actualSkillLevel;
  private int detailLevel;
  private String programmLang;
  private double initialSkillLevel;
  private String currentConceptID;
  private PedagogicalModuleFacade pmf;
  private StudentModelAssessment smAssess;

  public Course(PedagogicalModuleFacade p) {
    pmf = p;
  }

  /** pokrece se na pocetku sesije a sluzi da se inicijalizuje InstructionalPlanner
   * i da se unesu podaci o korisniku*/
  public void initializeUser(int uId, double stActSkLev,double initSkLev, int detLev, String programmLang) {

    userId = uId;
    actualSkillLevel = stActSkLev;
    detailLevel = detLev;
    initialSkillLevel=initSkLev;
    this.programmLang=programmLang;
    dPlanner = new DiscoursePlanner(this);

    smAssess = new StudentModelAssessment(this,initialSkillLevel);

    smAssess.setStudActualSkillLevel(actualSkillLevel);

    dPlanner.setStudentData(userId, stActSkLev, detLev, programmLang);


    dPlanner.createConceptPlan();

    startSession();

  }
  //preuzima vektor sa nazivima koncepata za chart dijagram
public String[] getConceptsTitles(){
  String[] concepts=pmf.getConceptsTitles();
  return concepts;
}
//preuzima vektor sa ocenama koncepata za chart dijagram
public double[] getConceptsDegrees(){
 double[] degrees = pmf.getConceptsDegrees();
 return degrees;
}
//preuzima vektor sa trenutnim znanjem u toku ucenja  koncepata za chart dijagram
public double[] getActualKnowledgeLevel(){
 double[] actKnowlLevel = pmf.getActualKnowledgeLevel();
 return actKnowlLevel;
}


  public void startSession() {

    dPlanner.startSession();

    pmf.startNewConcept();

  }

  public String readNextLesson() {

    String lId = dPlanner.readNextLesson();

    return lId;
  }
  public String readParticularLesson(String uId){

    String lId=dPlanner.readParticularLesson(uId);

    return lId;
  }

  public void setLessonReadingParameter(boolean val) {
    pmf.setLessonReadingParameter(val);
  }
  /** Salje signal da je upravo procitana poslednja lekcija
  * za dato poglavlje */
  public void setFinishLessonsFlag(boolean val){

    pmf.setFinishLessonsFlag(val);
  }
  /**Poziva funkciju iz instrukcionog plana koja vraca
   * vektor u kome se nalaze izabrani fragmenti za dati Unit*/
  public Vector getFragmentVectorForUnit(String currUnitId) {
    Vector fVect = dPlanner.getFragmentVectorForUnit(currUnitId);
    return fVect;
  }

  public int getNumberOfLessons() {
    int nol = dPlanner.getNumberOfLessons();
    return nol;
  }

  public String selectTest(int pos) {
    String val = dPlanner.selectTest(pos);
    return val;
  }

  public void selectCurrentConcept() {

    dPlanner.selectCurrentConcept();

  }
  public void selectParticularConcept(String currentConceptId){
    dPlanner.selectParticularConcept(currentConceptId);
  }

  public void setCurrentConceptID(String currConcID) {
    currentConceptID = currConcID;
    pmf.setCurrentConceptId(currentConceptID);
    smAssess.signalNewConcept();
  }

  public Vector addPassedConceptsFromStMod() {
    Vector passedConcepts = pmf.addPassedConceptsFromStMod();
    return passedConcepts;
  }

  public void setTestInSM(String qId, int gr) {
    pmf.setTestInSM(qId, gr);
  }

  /**Vraca broj pitanja u instrukcionom planu za dati koncept*/
  public int getNumberOfQuestions() {
    int noq = dPlanner.getNumberOfQuestions();
    return noq;
  }

  /**Pronalazi ID pitanja na osnovu njegovog rednog broja u vektoru*/
  public String getQuestionByOrdNum(int ordN) {
    String qid = dPlanner.getQuestionByOrdNum(ordN);
    return qid;
  }

  public void sendStudentAnswerBackFromDM(String questId,String questContent, int studAnswer,
      int indexOfTruthAnsw, String textOfTruthAnsw, String qRelatedTo,int qGroup,
      int questionDifficultyLevel, int optTimeToSolveQuest) {
    smAssess.sendStudentAnswerFromDM(questId, questContent, studAnswer,
                                     indexOfTruthAnsw, textOfTruthAnsw,
                                     qRelatedTo,qGroup, questionDifficultyLevel, optTimeToSolveQuest);

  }
  public void cleanStudAnswVector(){
    smAssess.cleanStudAnswVector();
  }
  public void signalEndOfSendingStudentAnswers(int duration){
    smAssess.signalEndOfSendingStudentAnswers(duration);
  }
  public void sendFeedbackText(double testKnowledgeLevel,double testDifficultyFactor,double testSuccess,String mainTestMessage,
                               int numOfQuest,int numOfWrongAnsw, int testDuration, double testPointsNumber){
    pmf.sendFeedbackText(testKnowledgeLevel,testDifficultyFactor,testSuccess,mainTestMessage,
                         numOfQuest,numOfWrongAnsw, testDuration, testPointsNumber);
  }
  /**Vraca tekst pitanja na koje je student netacno odgovorio.
    * Kao parametar se prosledjuje redni broj pitanja*/
   public String getWrongQuestContent(int ordNum){
     String cont=smAssess.getWrongQuestContent(ordNum);
     return cont;
   }
   /**Vraca tacan odgovor na pitanje koje student nije tacno
    * odgovorio. Kao parametar se prosledjuje redni broj pitanja*/
   public String getWrongQuestTruthAnswer(int ordNum){
     String answ=smAssess.getWrongQuestTruthAnswer(ordNum);
     return answ;
   }
   /**Pronalazi ID lekcije koju student treba da ponovi*/
  public String  getLessonToReLearn(int ordNum){
     String lessId=smAssess.getLessonToReLearn(ordNum);
   return lessId;

 }
 /**Vraca broj dodatnih lekcija koje je Tutor preporucio studentu*/
 public int getNumbOfAdditionalLessons(){
   int numb=smAssess.getNumbOfAdditionalLessons();
   return numb;
 }
 /**pronalazi ID dodatne lekcije*/
 public String getAdditLessId(int ordNum){
   String lessId=smAssess.getAdditLessId(ordNum);
   return lessId;
 }
 public void addFragmentsForOneUnit(String uid) {
    dPlanner.addFragmentsForOneUnit(uid);

  }
  /**Vraca broj netacnih pitanja kako bi se napravio novi Procedure Set*/
  public int getNumberOfWrongAnswers(){
    int qNum=smAssess.getNumberOfWrongAnswers();
    return qNum;
  }
  /**Vraca grupu pogresno odgovorenog pitanja na osnovu
   * rednog broja netacnog pitanja*/
  public int getWrongQuestionGroup(int ordNum){
    int qGroup=smAssess.getWrongQuestionGroup(ordNum);

    return qGroup;
  }
  /**Uklanja sve elemente vektora ProcedureSet*/
  public void cleanProcedureSet(){
    dPlanner.cleanProcedureSet();
  }
  /**Bira jedno od pitanja i ubacuje u instrukcioni plan*/
  public void putQuestInQuestPlan(int qGroup){
    dPlanner.putQuestInQuestPlan(qGroup);

  }
  /**Dodaje predjena pitanja u Rete*/
  public void addPassedQuestionsToRete(){
    dPlanner.addPassedQuestionsToRete();

  }
  /**Pronalazi broj koncepata koji su izabrani u instrukcioni plan*/
   public int getNumOfConceptsInPlan(){
     int cNum=dPlanner.getNumOfConceptsInPlan();
     return cNum;
   }
   /**Pronalazi id koncepta na osnovu rednog broja
    * za sadrzaj na stranici*/
   public String getConceptIdByOrdNum(int ordNum){
     String cId=dPlanner.getConceptIdByOrdNum(ordNum);
     return cId;
   }
   /**Salje signal u model studenta da kreira novu instancu testa*/
 public void startTestInSM(){
   pmf.startTestInSM();
 }
 /**Dodaje podatke o odredjenom pitanju iz testa u model studenta*/
 public void addQuestionToSM(String qId,int qGroup,boolean qTruth){
   pmf.addQuestionToSM(qId,qGroup,qTruth);
 }
 /**Salje ocenu testa i trenutni stepen znanja studenta u model studenta*/
 public void setTestElementsInSM(double testKnowledgeLevel,double testDifficultyFactor,
                                 double actSkillLev, double testSuccess, double testPointsNumber){
   pmf.setTestElementsInSM(testKnowledgeLevel,testDifficultyFactor,actSkillLev, testSuccess, testPointsNumber);
 }
 /**Poziva procenu znanja studenta za predjeni koncept */
  public void startConceptAssessment(){
    smAssess.startConceptAssessment();
  }
  public void changeStudentActualSkillLevel(double actualSkillLevel){

    this.actualSkillLevel=actualSkillLevel;
    dPlanner.setStudActualSkillLevel(actualSkillLevel);
    pmf.changeActualSkillLevel(actualSkillLevel);
    dPlanner.changeConceptPlan();
  }
  /**Salje ocenu za odredjeno poglavlje u klasu GlobalAssessment,
    * radi dobijanja prosecne ocene*/
   public void sendConceptMarkInPedMod(double mark){
     smAssess.sendConceptMarkInPedMod(mark);

   }
   /**Salje podatke o upravo zavrsenom konceptu u model studenta*/
   public void sendConceptDataToSM(double currConceptDegree,double studSkillLevel){
     pmf.sendConceptDataToSM(currConceptDegree,studSkillLevel);
   }
   /**pronalazi id lekcije na osnovu njenog rednog broja*/
   public String getUnitIdByOrdNum(int ordNum){

     String unitId=dPlanner.getUnitIdByOrdNum(ordNum);
     return unitId;
   }
   //vraca URL LOM xml dokumenta
   public String getLomURL(){
     String lomURL=pmf.getLomURL();
     return lomURL;
   }
   public void setChartsRef(ConceptHitChart conceptHitChart){
    smAssess.setChartsRef(conceptHitChart);
  }
  public int getNumberOfQuestInTest(int i){
     int qNumb=pmf.getNumberOfQuestInTest(i);
     return qNumb;
   }
   public double getTestDegreeByOrdNum(int i){
     double degreeT=pmf.getTestDegreeByOrdNum(i);
     return degreeT;
   }
   public int getNumberOfTests(){
    int numb=pmf.getNumberOfTests();
    return numb;
  }
  public String getRulesURI(){
    String uri=pmf.getRulesURI();
    return uri;
  }
  public String findPreviousLessonId(String currUnitId){
     String privUnitId=dPlanner.findPreviousLessonId(currUnitId);
     return privUnitId;
 }




}
