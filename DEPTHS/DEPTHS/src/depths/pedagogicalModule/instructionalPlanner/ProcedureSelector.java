/* Generated by Together */

package depths.pedagogicalModule.instructionalPlanner;

import jess.*;
import java.util.*;

public class ProcedureSelector {
  public ProcedureSelector(DiscoursePlanner dp,InstructionalPlan ip,LOM_reader_Mgr lrM){
    dPlanner=dp;
    iPlan=ip;
    lrMgr=lrM;
  }

    public void setStudActualSkillLevel(double skl){
      studActualSkillLevel=skl;
     }
    public void setCurrentConceptID(String ccID){
      currentConceptID=ccID;
    }
    public void setStudentDetailLevel(int dl){
      studentDetailLevel=dl;
    }
    /** Osnovna funkcija koja se poziva da bi se
     * kreirao skup pitanja koja ce se postaviti studentu
     * po zavrsetku poglavlja   */
    public void createProcedureSet(){
      iPlan.cleanProcedureSet();
      //ucitaj podatke u Jess za
      //vrednost currConcept
     lrMgr.createQuestionReaderParser(currentConceptID,this);

      for (int i=1;i<6;i++){
        //poziv funkcije koja ce da cita podatke za jednu grupu
        //readOneGroup(i);
        //return QuestionID
        this.questAllreadyRemoved=false;

        putQuestionInQuestPlan(i);

      }
    }


	/**dodaje u Jess pitanja koja su vec postavljena
	 * - treba ubaciti poziv funkcije u trenutku izvrsenja
	 * instrukcionog plana */
	  public void addPassedQuestionToRete(String qID) {
		try {
		  fpq = new Fact("passed_question", engine);
		  fpq.setSlotValue("ID", new Value(qID, RU.STRING));
		  engine.assertFact(fpq);
		  }
		catch (JessException je) {
		  System.out.println("ERROR addPassedQuestions ");
		}
	  }

    /** Pokrece upit find-questions koji se izvrsava u Jessu
     * i pronalazi sva pitanja iz odgovarajuce grupe       */
    public void putQuestionInQuestPlan(int groupId){
      if (studActualSkillLevel<1.5){
        tempDiffLev=1;
      }else if (studActualSkillLevel<2.5){
        tempDiffLev=2;
      }else if (studActualSkillLevel<3.5){
        tempDiffLev=3;
      }else if (studActualSkillLevel<4.5){
        tempDiffLev=4;
      }else {
        tempDiffLev=5;
      }








      emptyGroup=false;
        try {
        ValueVector vq = new ValueVector();
        vq.add(new Value(currentConceptID, RU.STRING));
        vq.add(new Value(groupId, RU.INTEGER));
        vq.add(new Value(studActualSkillLevel, RU.INTEGER));

        Iterator it = engine.runQuery("find-questions", vq);
        try {

            if (it.hasNext()) {

            Token t = (Token) it.next();
            Fact f = t.fact(1);
            String concId = f.getSlotValue("conceptID").stringValue(null);
            String id = f.getSlotValue("ID").stringValue(null);
            int group = f.getSlotValue("group").intValue(null);
            int difficultyLevel = f.getSlotValue("difficultyLevel").intValue(null);
            String relatedTo = f.getSlotValue("related-to").stringValue(null);
            qInfo = new QuestionInfo(concId, id, group, difficultyLevel,
                                     relatedTo);
            iPlan.putQuestionInPlan(groupId, qInfo);


          }
          else {

            this.searchAgainForQuestion(groupId);
            tempDiffLevUp=false;
          }
        }
        catch (NoSuchElementException ex) {
          System.out.println("ERROR  : NoSuchElementException");
        }
      }

        catch (JessException je) {
          System.out.println("ERROR  : JessException " + je.getMessage());
        }
     }
     	/**Dodaje postavljena pitanja u Jess kako se ne bi ponavljala - nije implementirana*/
public void addPassedQuestionToJess(){
  int qNum;
  qNum=iPlan.getNumberOfQuestions();
  for (int i=0;i<qNum;i++){

    String qId = iPlan.getQuestionByOrdNum(i);

    this.addPassedQuestionToRete(qId);
  }

}
		/** regulise smanjivanje stepena slozenosti ukoliko
		 * za prethodni stepen slozenosti nije pronadjeno nijedno pitanje */
    public void increaseDiffLev(int group,double studActSkLev){
      int temp=0;
      if(studActSkLev<1.5){
        temp=1;
      }else if(studActSkLev<2.5){
        temp=2;
      }else if(studActSkLev<3.5){
        temp=3;
      }else if(studActSkLev<4.5){
        temp=4;
      }else {
        temp=5;
      }






      if (tempDiffLevUp){
        if(tempDiffLev==6){

          emptyGroup=true;
        }else{
          tempDiffLev++;
        }
      }else{
        if (tempDiffLev==1){
          tempDiffLevUp=true;
          tempDiffLev=temp;
          tempDiffLev++;
        }else{
          tempDiffLev--;
        }
      }
    }
	/** Poziva se kada se za studentov stepen znanja ne pronadje nijedno
	 * pitanje. U tom slucaju se smanjuje stepen slozenosti pitanja	  */
	public void searchAgainForQuestion(int groupId){

          this.increaseDiffLev(groupId, tempDiffLev);

          //if (emptyGroup==false) {
          if (tempDiffLev<6){
            try {
              ValueVector vtq = new ValueVector();
              vtq.add(new Value(currentConceptID, RU.STRING));
              vtq.add(new Value(groupId, RU.INTEGER));
              vtq.add(new Value(tempDiffLev, RU.INTEGER));
              Iterator itt = engine.runQuery("find-questions", vtq);
              try {
                if (itt.hasNext()) {
                  Token tt = (Token) itt.next();
                  Fact ft = tt.fact(1);
                  String concId = ft.getSlotValue("conceptID").stringValue(null);
                  String id = ft.getSlotValue("ID").stringValue(null);
                  int group = ft.getSlotValue("group").intValue(null);
                  int difficultyLevel = ft.getSlotValue("difficultyLevel").intValue(null);
                  String relatedTo = ft.getSlotValue("related-to").stringValue(null);
                  qInfo = new QuestionInfo(concId, id, group, difficultyLevel,
                                           relatedTo);
                  iPlan.putQuestionInPlan(groupId, qInfo);

                }
                else {
                  this.searchAgainForQuestion(groupId);
                }
              }

              catch (NoSuchElementException ex) {
                System.out.println("ERROR  : NoSuchElementException");
              }
            }

              catch (JessException je) {
                System.out.println("ERROR  : JessException " + je.getMessage());
              }

          }else {

          if (this.questAllreadyRemoved==false){

            fRetractor.removeQuestionFromJess(this.currentConceptID, groupId);
            this.questAllreadyRemoved = true;
            this.tempDiffLevUp=false;
            this.putQuestionInQuestPlan(groupId);
          }

            //pozvati funkciju koja ce da izbaci pitanja iz Jess memorije
            // u slucaju da nema vise pitanja
                 //int concId = currentConceptID;
                  //int id = 0;
                  //int group = groupId;
                  //int difficultyLevel = 0;
                  //int relatedTo = 0;
                  //qInfo = new QuestionInfo(concId, id, group, difficultyLevel,
                   //                        relatedTo);
                  //iPlan.putQuestionInPlan(groupId, qInfo);

          }
        }




    public void endQuestion(){
      addQuestionFact();
    }
    public void setQuestGroup(int g){
      QuestGroup=g;
    }
    public void setQuestId(String id){
      QuestID=id;
    }
    public void setQuestDiffLev(int dl){
      QuestDiffLev=dl;
    }
    public void setQuestionRelatedTo(String relto){
      QuestRelTo=relto;
    }
    public void setEngineReference(Rete en){
      engine=en;
    }
    public int getQuestGroup(){
      return QuestGroup;
    }
    public String getQuestId(){
      return QuestID;
    }
    public int getQuestDiffLev(){
      return QuestDiffLev;
    }
    public String getQuestRelatedTo(){
      return QuestRelTo;
    }
    public void setQuestAllreadyRemoved(boolean val){
      this.questAllreadyRemoved=val;
    }

    /**treba da doda Question u Jess memoriju*/
  public void addQuestionFact() {
    try {
      Fact fp = new Fact("question", engine);
      fp.setSlotValue("conceptID", new Value(currentConceptID, RU.STRING));
      fp.setSlotValue("ID",new Value(getQuestId(), RU.STRING));
      fp.setSlotValue("group", new Value(getQuestGroup(), RU.INTEGER));
      fp.setSlotValue("difficultyLevel", new Value(getQuestDiffLev(), RU.INTEGER));
      fp.setSlotValue("related-to", new Value(getQuestRelatedTo(), RU.STRING));
      engine.assertFact(fp);
    }
    catch (JessException je) {
      System.out.println("ERROR addQuestionFacts function JessException " +
                         je.getMessage());
    }
  }
  public void setFactRetractRef(FactRetractor fRetr){
   fRetractor=fRetr;
 }
  private FactRetractor fRetractor;
    private String teachingStrategy;
    private String questionTitle;
    private double studActualSkillLevel;
    private String currentConceptID;
    private int studentDetailLevel;
    private InstructionalPlan iPlan;
    private DiscoursePlanner dPlanner;
    private String learningStyle;
    private LOM_reader_Mgr lrMgr;
    private int QuestGroup;
    private String QuestID;
    private int QuestDiffLev;
    private String QuestRelTo;
    private Rete engine;
    private boolean emptyGroup=false;
    /** Vektor u koji se privremeno smestaju pitanja iz jedne grupe pre nego sto se prebace u
     * instrukcioni plan     */
    private Vector groupVect;
    private QuestionInfo qInfo;
    private int tempDiffLev=0;
    private boolean tempDiffLevUp=false;
    private boolean gvCreated=false;
    private Fact fpq;
    private boolean questAllreadyRemoved=false;//oznacava da nije pronadjeno drugo za ponovljeni test,
    //pa je iz Jessa izbaceno vec postavljeno pitanje



}
