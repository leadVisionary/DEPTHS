/* Generated by Together */

package depths.pedagogicalModule.instructionalPlanner;
import java.util.*;

public class InstructionalPlan {
  public InstructionalPlan(DiscoursePlanner dp) {
    dPlanner = dp;
    conceptPlan = new Vector();
    conceptPlanFinal = new Vector();
    passedConcepts = new Vector();
  }

  /**dodaje predjeni koncept u listu predjenih koncepata*/
  public void addPassedConcept(String cID) {
    concID = cID;
    passedConcepts.addElement(concID);
}

  /**dodaje dati koncept u plan koncepata pod uslovom da isti nije
   *vec unet u plan koncepata i da nije u listi predjenih koncepata    */
  public boolean addConceptInPlan(String cID) {
    if (checkIfConceptAlreadyInPlan(cID)) {

      return false;
    }
    else {
      if (checkIfConceptAlreadyPassed(cID)) {

            return false;
      }
      else {

        if (conceptPlanFinal.isEmpty()) {
          conceptPlan.addElement(cID);

        }
        else {
          conceptPlanFinal.addElement(cID);

        }

        return true;
      }
    }
  }

  /**proverava da li je dati koncept vec unet u instrukcioni plan
   *ako jeste vraca TRUE, ako nije vraca FALSE    */
  private boolean checkIfConceptAlreadyInPlan(String cID) {
    if (conceptPlan.contains(cID)) {
      return true;
    }
    else {
      return false;
    }
  }
  /**proverava da li je dati koncept vec predjen
   *ako jeste vraca TRUE, ako nije vraca FALSE    */
  private boolean checkIfConceptAlreadyPassed(String cID) {
    if (passedConcepts.contains(cID)) {
      return true;
    }
    else {
      return false;
    }
  }
  /** Okrece vektor u kome je smesten plan koncepata   */
  public void turnVectorAround() {

try{
    int vectorCapacity =conceptPlan.size();

    for (int i = 0; i < vectorCapacity ; i++) {

      conceptPlanFinal.add(i, conceptPlan.elementAt(vectorCapacity - i-1));

    }
    int newVectorCapacity = conceptPlanFinal.size();


    //ova petlja moze da se obrise
    for (int s = 0; s < newVectorCapacity ; s++) {
    }
  }
    catch(NullPointerException ne){
      System.out.println("ERROR in InstructionalPlan.java method turnVectorAround() type of error=NULL POINTER");
    }
  }
/**  Dodaje Unit u plan lekcija  */
  public void addUnitInPlan(UnitInfo ui, int pos) {

    int position = pos;
    lPlan.put(new Integer(position), ui);
  }

  /**proverava da li plan lekcija ima sve potrebne lekcije
   *vraca false ako lekcija nije uneta u hash tabelu
   */
  public boolean checkLessonPlan(int lId) {

    int lessKey = lId + 1;
    if (lPlan.containsKey(new Integer(lessKey))) {
      UnitInfo ui = (UnitInfo) lPlan.get(new Integer(lessKey));
      return true;
    }
    else {
    }
    return false;
  }
  /**
   *vrsi izbor trenutnog koncepta koji ce se uciti
   * @return int
   */
  public String selectCurrentConcept() {


try{
  if (! (currentConceptID.equals("0"))) {

    removeCurrentConcept();

  }

  lPlan.clear();

  currentConceptID = conceptPlanFinal.firstElement().toString();

  passedLessonsCounter = 0;
}catch(NullPointerException ne){
  System.out.print("  GRESKA NULL POINTER EXCEPTION ");

}catch(NoSuchElementException nse){
  System.out.print("  ERROR NO SUCH ELEMENT EXCEPTION ");
}
    return currentConceptID;
  }
  public void selectParticularConcept(String curConc){

    //if (! (currentConceptID.equals("0"))){
      //removeCurrentConcept();
    //}
    lPlan.clear();
    currentConceptID = curConc;
    passedLessonsCounter=0;
  }

  /**  uklanja prvi koncept iz vektora    */
  public void removeCurrentConcept() {


    cSel.addPassedConcepts(currentConceptID);
    int concIndex=(conceptPlanFinal.indexOf(currentConceptID));
    if (concIndex>=0){
      conceptPlanFinal.remove(concIndex);
    }
  }

  /**  postavlja referencu na objekat klase ConceptSelecor  */
  public void setConcSelectReference(ConceptSelector cs) {
    cSel = cs;
  }
  /**poziva sledecu lekciju iz instrukcionog plana*/
  public String readNextUnitFromPlan(){

     String lId="0";
    //fragmentsPlan.clear();
    try{
      numberOfLessons = lPlan.size();
      passedLessonsCounter++;
      if (passedLessonsCounter == numberOfLessons) {
        dPlanner.setFinishLessonsFlag(true);
      }
      UnitInfo ui = (UnitInfo) lPlan.get(new Integer(passedLessonsCounter));
      lId = ui.getID();
    }catch (NullPointerException npe){
      System.out.println("ERROR NULL POINTER EXCEPTION");
    }
      return lId;
 }
 public String readParticularUnitFromPlan(String uId){

   String lId=uId;
   try{

      numberOfLessons = lPlan.size();

      //passedLessonsCounter++;
      for (int i=1;i<numberOfLessons;i++){

        UnitInfo ui = (UnitInfo) lPlan.get(new Integer(i));
        String tempId=ui.getID();

        if (tempId.equals(lId)) {
          passedLessonsCounter=i-1;
            }
      }
    }catch (NullPointerException npe){
      System.out.println("ERROR NULL POINTER EXCEPTION");
    }

   return lId;
 }
  /** dodaje fragmente u instrukcioni plan   */
  public void addFragmentsInPlan() {

    int unitNumber = lPlan.size();

    lrMgr.createFragmentsReaderParser(currentConceptID);

    for (int i = 1; i < unitNumber+1 ; i++) {

      UnitInfo unit = (UnitInfo) lPlan.get(new Integer(i));

      String uID = unit.getID();

      fSel.setCurrUnitID(uID);

      fSel.setStudentDetailLevelTemp(fSel.getStudentDetailLevel());

      addFragmentsForOneUnit(uID);

    }

  }
  /**ova funkcija treba da pokrene parser i da pronadje fragmente
   * za odredjeni unit a zatim ubaci te fragmente u hash tabelu  */
  public void addFragmentsForOneUnit(String uid) {

    fSel.setFragmentsForLessonCounter(0);

    fSel.setCurrUnitID(uid);

    lrMgr.runFragmentsReaderParser(uid);



    if (fSel.getFragmentsForLessonCounter()==0){


      fSel.setStudentDetailLevelTemp(fSel.getStudentDetailLevel()+1);

      this.addFragmentsForOneUnit(uid);
      //
    }
  }
public void setReferences(LOM_reader_Mgr lr,FragmentsSelector fs){
  lrMgr=lr;
  fSel=fs;
}
/** stavlja Vektor fragmenata u hash tabelu  */
public void putFragmentVectorInPlan(String curUnId,Vector v){

  fragmentsPlan.put(curUnId,v);
 }
/**uzima Vektor fragmenata za dati Unit*/
 public Vector getFragmentVectorForUnit(String currUnitId){

   Vector frPlan;
   frPlan=(Vector) fragmentsPlan.get(currUnitId);

   return frPlan;
 }
 /** Stavlja pitanje u plan pitanja za dati koncept */
 public void putQuestionInPlan(int groupId,QuestionInfo qInfo){

       int n=groupId-1;
       	procedureSet.add(questCounter,qInfo);

        questCounter++;
 }
 public void cleanProcedureSet(){
   procedureSet.removeAllElements();
   questCounter=0;
 }
 /**Vraca broj lekcija u trenutnom konceptu*/
 public int getNumberOfLessons(){
 	return numberOfLessons;
 }
 /**preuzima jedno pitanje iz procedure set-a*/
 public String selectTest(int pos){

 	QuestionInfo qInfo=(QuestionInfo) procedureSet.get(pos);
 	String qId=qInfo.getID();
         int group=qInfo.getGroup();
         dPlanner.setTestInSM(qId,group);

 	return qId;
 }
 /** Vraca broj pitanja u instrukcionom planu za trenutni koncept*/
 public int getNumberOfQuestions(){
   int noq;
   try{
     noq = procedureSet.size();
   }catch (NoSuchElementException e){
     noq=0;
   }

   return noq;
 }

 /** Vraca ID broj za pitanje koje se nalazi pod odredjenim rednim brojem u vektoru
  * instrukcionog plana*/
 public String getQuestionByOrdNum(int ordN){


   QuestionInfo reqQInfo=(QuestionInfo) procedureSet.get(ordN);

   String qId=reqQInfo.getID();


   return qId;
 }
 /**Pronalazi broj koncepata koji su izabrani u instrukcioni plan*/
   public int getNumOfConceptsInPlan(){
     int cNum=0;
     try {
       cNum = conceptPlanFinal.size();
     }catch (NoSuchElementException nse){
     System.out.println("ERROR NO SUCH ELEMENT EXCEPTION");}
     return cNum;
   }
   /**Pronalazi id koncepta na osnovu rednog broja
    * za sadrzaj na stranici*/
   public String getConceptIdByOrdNum(int ordNum){
     String cId="";
     try{
       cId = conceptPlanFinal.get(ordNum).toString();
     }catch (ArrayIndexOutOfBoundsException aie){
       System.out.println("ERROR ArrayIndexOutOfBounds EXCEPTION");
     }
     return cId;
   }
   /**pronalazi id lekcije na osnovu njenog rednog broja*/
   public String getUnitIdByOrdNum(int ordNum){
     UnitInfo ui = (UnitInfo) lPlan.get(new Integer(ordNum));
     String unitId= ui.getID();


     return unitId;
   }

   public void cleanBothConceptPlans(){

     conceptPlan.removeAllElements();
     conceptPlanFinal.removeAllElements();
   }
   public String findPreviousLessonId(String currUnitId){
     String privUnitId="noPreviewLesson";
     int x=lPlan.size();
     int y=0;
     for (int i=1;i<x;i++){
       UnitInfo ui = (UnitInfo) lPlan.get(new Integer(i));
       if (ui.getID().equals(currUnitId)) {

         y = ui.getOrdinalNumber();

       }
     }
    if (y>1){
      UnitInfo prevUnit = (UnitInfo) lPlan.get(new Integer(y-1));
      privUnitId=prevUnit.getID();
    }

   return privUnitId;
 }

  private Hashtable lPlan = new Hashtable();
  /**hash tabela kljuc vrednosti unit - vektor fragmenata*/
  private Hashtable fragmentsPlan = new Hashtable();
  private String currentConceptID = "0";
  private Vector conceptPlan;
  private Vector conceptPlanFinal;
  private Vector procedureSet=new Vector();
  private Vector passedConcepts;
  private DiscoursePlanner dPlanner;
  private String concID;
  private ConceptSelector cSel;
  private LOM_reader_Mgr lrMgr;
  private FragmentsSelector fSel;
  /**Broj lekcija u trenutnom konceptu*/
  private int  numberOfLessons;
  private int  passedLessonsCounter;
  private int questCounter=0;
}
