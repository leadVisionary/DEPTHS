/* Generated by Together */

package depths.pedagogicalModule.studentAssessment;
import java.util.Vector;

public class GlobalAssessment {
  public GlobalAssessment(StudentModelAssessment smAss,double initSkLev){
    smAssess=smAss;
    initialSkillLevel=initSkLev;
  }
  public double getActualSkillLevel(){
    return actualSkillLevel;
  }

  public void setActualSkillLevel(double actualSkillLevel){
      this.actualSkillLevel= actualSkillLevel;
    }

  public double getNewSkillLevel(){
    return newSkillLevel;
  }

  public void setNewSkillLevel(double newSkillLevel){
      this.newSkillLevel= newSkillLevel;
    }
    /**Dodaje ocenu trenutno zavrsenog testa u Vector koji cuva sve ocene testova
     * za trenutni koncept*/
    public void addTestMark(double mark){
      testsDegree.addElement(new Double(mark));
    }

    /**Vrsi procenu znanja studenta za predjeni koncept */
  public void startConceptAssessment(){
int allQuestNum=0;
    int numOfTests=smAssess.getNumberOfTests();
    double sum=0.0,temp=0.0;
    for (int i=0;i<numOfTests;i++){
      int questNum=smAssess.getNumberOfQuestInTest(i);
      allQuestNum=allQuestNum+questNum;
      double tm=smAssess.getTestDegreeByOrdNum(i);
      tm=tm*questNum;
      sum=sum+tm;
    }
    temp=sum/allQuestNum;
  currConceptDegree=temp;
       allConceptsMarks.addElement(new Double(currConceptDegree));
       calcStudSkillLevel();
       smAssess.sendConceptDataToSM(currConceptDegree,newSkillLevel);
       if (this.checkNewSkillLevel()==false){
         actualSkillLevel=newSkillLevel;
       }else {
         actualSkillLevel=newSkillLevel;
         this.lastChangingSkillLevel=actualSkillLevel;
         smAssess.changeConceptPlan(actualSkillLevel);
         }
    }
    //vrsi proveru novog stepena znanja studenta da bi se utvrdilo da li je potrebna promena
   //plana koncepata
   public boolean checkNewSkillLevel(){
     if(lastChangingSkillLevel==0){
       this.lastChangingSkillLevel=actualSkillLevel;
     }
     if((newSkillLevel-lastChangingSkillLevel)>1){


       return true;
     }else if((lastChangingSkillLevel-newSkillLevel)>1){


       return true;
     }else{



       return false;
     }
   }

    public void cleanTestVector(){
      testsDegree.removeAllElements();
    }
    /**Izracunava stepen trenutnog znanja studenta
     * uzevsi u obzir i inicijalni stepen znanja i ocene sa svih koncepata*/
    public void calcStudSkillLevel(){
      double sum=initialSkillLevel;
      int numOfPassConcepts=allConceptsMarks.size();
      for (int i=0;i<numOfPassConcepts;i++){
        double markToAdd=Double.parseDouble(allConceptsMarks.get(i).toString());
        sum=sum+markToAdd;
      }
      double s=sum/(numOfPassConcepts+1);
     /* if (s<=1.50){
        newSkillLevel=1;
      }else if ((s>1.50)&&(s<=2.50)){
        newSkillLevel=2;
      }else if ((s>2.50)&&(s<=3.50)){
        newSkillLevel=3;
      }else if ((s>3.50)&&(s<=4.50)){
        newSkillLevel=4;
      }else if (s>4.50){
        newSkillLevel=5;
      }*/
     newSkillLevel=s;

    }



  private double actualSkillLevel;
  private double newSkillLevel;
  private double lastChangingSkillLevel;
  private Vector testsDegree=new Vector();
  private Vector allConceptsMarks=new Vector();
  private double initialSkillLevel;
  private StudentModelAssessment smAssess;
  private double currConceptDegree;
}
